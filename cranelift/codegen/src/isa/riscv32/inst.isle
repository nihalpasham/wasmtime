;; Instruction formats.
(type MInst
  (enum
    ;; A no-op of zero size.
    (Nop0)
    (Nop4)

    ;; load immediate
    (Lui
      (rd WritableReg)
      (imm Imm20))

     (Auipc
      (rd WritableReg)
      (imm Imm20))
    
    ;; The LoadInlineConst operation represents the action of loading an immediate constant 
    ;; (a constant value) directly into a register. This operation is often used when you 
    ;; need to set a register to a specific constant value, such as zero, one, or any other 
    ;; immediate value, without needing to calculate it or load it from memory.
    (LoadInlineConst
      (rd WritableReg)
      (ty Type)
      (imm u64))
    
    (AluRRR
      (alu_op AluOPRRR)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg))

    ;; I-type Layout:
    ;; 0-------6-7-------11-12------14-15------19-20------------------31
    ;; | Opcode |   rd     |  width   |   rs1    |     Offset[11:0]    |

    ;; The I-type Instruction Format i.e. uses one source register, one immediate and a destination register.
    (AluRRImm12
      (alu_op AluOPRRI)
      (rd WritableReg)
      (rs Reg)
      (imm12 Imm12))

    ;; Uses the I-type Instruction Format. In non-immediate CSR instructions (CSRRW, CSRRS, CSRRC), rs1 is 
    ;; used to specify the register with the value to write.
    (CsrReg
      (op CsrRegOP)
      (rd WritableReg)
      (rs Reg)
      (csr CSR))

    ;; Uses the I-type Instruction Format. In immediate CSR instructions (CSRRWI, CSRRSI, CSRRCI), rs1 is 
    ;; replaced by a 5-bit immediate value.
    (CsrImm
      (op CsrImmOP)
      (rd WritableReg)
      (imm UImm5)
      (csr CSR))

    ;; Loads use the I-type Instruction Format.
    ;; Each load instruction in RV32I takes two operands
    ;; - A destination register (e.g., rd), where the data will be loaded.
    ;; - A base register (e.g., rs1) and an immediate offset, which together specify the memory address 
    ;; to load from.
    (Load
      (rd WritableReg)
      (op LoadOP)
      (flags MemFlags)
      (from AMode))
    
    ;; Pesudo load instructions

    ;; This operation loads the address of an external symbol (e.g., a function or global variable) 
    ;; into a register. In RISC-V, external symbols are often handled using relocation tables and 
    ;; require instructions like LUI to load the upper 20 bits of the address and ADDI to load the 
    ;; lower 12 bits.
    (LoadExtName
      (rd WritableReg)
      (name BoxExternalName)
      (offset i64))

    ;; This operation loads the address of a TLS (Thread-Local Storage) symbol into a register.
    ;; In RISC-V, accessing TLS typically involves a mechanism using the TLS base register 
    ;; (which stores the base address of the TLS area). The RISC-V instructions can then use 
    ;; PC-relative addressing or specialized instructions to load TLS data.
    (ElfTlsGetAddr
      (rd WritableReg)
      (name BoxExternalName))

    ;; This operation loads an address (a memory address or pointer) into a register.
    ;; RISC-V handles address calculation through instructions like add for register-based 
    ;; addressing or addi for immediate-based addressing.
    (LoadAddr
      (rd WritableReg)
      (mem AMode))
    
    ;; Uses the S-type Instruction Format.
    ;; Each store instruction in RV32I takes two operands:
    ;; - A source register (e.g., rs2), which holds the data to be stored.
    ;; - A base register (e.g., rs1) and an immediate offset, which together specify the memory address where 
    ;; the data will be stored.
    (Store
      (to AMode)
      (op StoreOP)
      (flags MemFlags)
      (src Reg))
    
    ;; A pseudo-instruction that captures register arguments in vregs.
    (Args
      (args VecArgPair))

    ;; A pseudo-instruction that moves vregs to return registers.
    (Rets
      (rets VecRetPair))

    (Ret)

    ;; A pseudo-instruction representing a register extension operation, typically used to modify the bit-width 
    ;; of data in a register (e.g., from 8-bit to 16-bit or 32-bit) by either sign-extending or zero-extending it.
    (Extend
      (rd WritableReg)
      (rn Reg)
      (signed bool)
      (from_bits u8)
      (to_bits u8))

    (Call (info BoxCallInfo))

    ;; A machine indirect-call instruction.
    (CallInd (info BoxCallIndInfo))

    ;; A direct return-call macro instruction.
    (ReturnCall (info BoxReturnCallInfo))

    ;; An indirect return-call macro instruction.
    (ReturnCallInd (info BoxReturnCallIndInfo))

    ;; Emits a trap with the given trap code if the comparison succeeds
    (TrapIf
      (rs1 Reg)
      (rs2 Reg)
      (cc IntCC)
      (trap_code TrapCode))
    
    ;; A pseudo-instruction for a conditional branch
    (CondBr
      (taken CondBrTarget)
      (not_taken CondBrTarget)
      (kind IntegerCompare))

    (Jal
      (label MachLabel))
    
    ;; A pseudo-instruction representing a `mov` instruction. These are encoded as OrR's (AluRRR form) but we
    ;; keep them separate at the `Inst` level for better pretty-printing and faster `is_move()` logic.
    (Mov
      (rd WritableReg)
      (rm Reg)
      (ty Type))
    

    (Fence
      (pred FenceReq)
      (succ FenceReq))

    (EBreak)

    ;; Conditional select i.e. select x if condition is true or y if condition is false. 
    (Select
      (dst WritableValueRegs)
      (condition IntegerCompare)
      (x ValueRegs)
      (y ValueRegs))

    ;; A pseudo-instruction. This operation represents a branch table or jump table operation, where a 
    ;; program can select one of several potential branch targets based on the value of an index 
    ;; register. This is useful for implementing switch-case logic or other scenarios where a single
    ;; control flow decision may have multiple possible outcomes.
    (BrTable
      (index Reg)
      (tmp1 WritableReg)
      (tmp2 WritableReg)
      (targets VecMachLabel))

    ;; An instruction guaranteed to always be undefined and to trigger an illegal instruction at
    ;; runtime.
    (Udf
      (trap_code TrapCode))
    
    ;; A jump and link register operation
    (Jalr
      ;;Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd=x0.
      (rd WritableReg)
      (base Reg)
      (offset Imm12))

    ;; An unwind pseudo-instruction.
    (Unwind
      (inst UnwindInst))

    ;; A dummy pseudo-instruction, useful to keep a value alive.
    (DummyUse
      (reg Reg))
    

    (RawData (data VecU8))

    ;; A pseudo-instruction to count the number of 1s in a register 
    ;; i.e., "population count" or "Hamming weight" without the hardware popcnt instruction.
    (Popcnt
      (sum WritableReg)
      (step WritableReg)
      (tmp WritableReg)
      (rs Reg)
      (ty Type))

    ;; A pseudo-instruction to count the number of leading or trailing zeros in `rs`
    (Cltz
      ;; leading or trailing.
      (leading bool)
      (sum WritableReg)
      (step WritableReg)
      (tmp WritableReg)
      (rs Reg)
      (ty Type))
    
    ;; A pseudo-instruction for a bit-reversal operation on an 8-bit value. 
    (Brev8
      (rs Reg)
      (ty Type)
      (step WritableReg)
      (tmp WritableReg)
      (tmp2 WritableReg)
      (rd WritableReg))

    ;; A pseudo-instruction for stack probing. 
    ;;
    ;; Allocating a large stack frame all at once can cause
    ;; issues, especially if it crosses over memory guard pages, which can
    ;; result in a segmentation fault or stack overflow.
    ;;
    ;; StackProbeLoop gradually allocates memory in smaller, safe increments
    ;; to ensure that each memory page is accessed in sequence. This way,
    ;; it prevents sudden large allocations from causing faults.
    ;;
    ;; Parameters:
    ;; - `guard_size` (u32): The size of each incremental allocation, typically
    ;;    matching the system's page size (e.g., 4KB).
    ;; - `probe_count` (u32): The total number of incremental steps needed to
    ;;    complete the allocation.
    ;; - `tmp` (WritableReg): A temporary register used for calculations in the loop.
    ;;
    ;; Example:
    ;; If you need 16KB of stack space and the `guard_size` is 4KB, StackProbeLoop
    ;; will allocate 4KB at a time, making four sequential increments.
    (StackProbeLoop
      (guard_size u32)
      (probe_count u32)
      (tmp WritableReg))
))

;; RV32I base set R-type
(type AluOPRRR (enum
  (Add)
  (Sub)
  (Sll)
  (Slt)
  (SltU)
  (Xor)
  (Srl)
  (Sra)
  (Or)
  (And)
))

;; RV32I base set I-type
(type AluOPRRI (enum
  (Addi)
  (Slti)
  (SltiU)
  (Xori)
  (Ori)
  (Andi)
  (Slli)
  (Srli)
  (Srai)
))

(type CsrRegOP (enum
  ;; Atomic Read/Write CSR
  (CsrRW)
  ;; Atomic Read and Set Bits in CSR
  (CsrRS)
  ;; Atomic Read and Clear Bits in CSR
  (CsrRC)
))

;; Enum of the known CSR registers
(type CSR (enum
  ;; Floating-Point Dynamic Rounding Mode
  (Frm)
))

(type CsrImmOP (enum
  ;; Atomic Read/Write CSR (Immediate Source)
  (CsrRWI)
  ;; Atomic Read and Set Bits in CSR (Immediate Source)
  (CsrRSI)
  ;; Atomic Read and Clear Bits in CSR (Immediate Source)
  (CsrRCI)
))

(type LoadOP (enum
  (Lb)
  (Lh)
  (Lw)
  (Lbu)
  (Lhu)
))

(type StoreOP (enum
  (Sb)
  (Sh)
  (Sw)
))


(type Imm20 (primitive Imm20))
(type Imm12 (primitive Imm12))
(type UImm5 (primitive UImm5))
(type AMode (primitive AMode))
(type IntegerCompare (primitive IntegerCompare))
(type BoxCallInfo (primitive BoxCallInfo))
(type BoxCallIndInfo (primitive BoxCallIndInfo))
(type BoxReturnCallInfo (primitive BoxReturnCallInfo))
(type BoxReturnCallIndInfo (primitive BoxReturnCallIndInfo))
(type FenceReq (primitive u8))
(type CondBrTarget (primitive CondBrTarget))
(type VecU8 (primitive VecU8))
(type VecMachLabel extern (enum))

;;;; Newtypes for Different Register Classes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(type XReg (primitive XReg))
(type WritableXReg (primitive WritableXReg))
(type VReg (primitive VReg))
(type WritableVReg (primitive WritableVReg))

;; Construct a new `XReg` from a `Reg`.
;;
;; Asserts that the register has a Integer RegClass.
(decl xreg_new (Reg) XReg)
(extern constructor xreg_new xreg_new)
(convert Reg XReg xreg_new)

;; Construct a new `WritableXReg` from a `WritableReg`.
;;
;; Asserts that the register has a Integer RegClass.
(decl writable_xreg_new (WritableReg) WritableXReg)
(extern constructor writable_xreg_new writable_xreg_new)
(convert WritableReg WritableXReg writable_xreg_new)

;; Put a value into a XReg.
;;
;; Asserts that the value goes into a XReg.
(decl put_in_xreg (Value) XReg)
(rule (put_in_xreg val) (xreg_new (put_in_reg val)))
(convert Value XReg put_in_xreg)

;; Convert an `InstOutput` out of a single XReg register.
(decl output_xreg (XReg) InstOutput)
(rule (output_xreg x) (output_reg x))
(convert XReg InstOutput output_xreg)

;; Convert a `WritableXReg` to an `XReg`.
(decl pure writable_xreg_to_xreg (WritableXReg) XReg)
(extern constructor writable_xreg_to_xreg writable_xreg_to_xreg)
(convert WritableXReg XReg writable_xreg_to_xreg)

;; Convert a `WritableXReg` to an `WritableReg`.
(decl pure writable_xreg_to_writable_reg (WritableXReg) WritableReg)
(extern constructor writable_xreg_to_writable_reg writable_xreg_to_writable_reg)
(convert WritableXReg WritableReg writable_xreg_to_writable_reg)

;; Convert a `WritableXReg` to an `Reg`.
(decl pure writable_xreg_to_reg (WritableXReg) Reg)
(rule (writable_xreg_to_reg x) (writable_xreg_to_writable_reg x))
(convert WritableXReg Reg writable_xreg_to_reg)

;; Convert an `XReg` to a `Reg`.
(decl pure xreg_to_reg (XReg) Reg)
(extern constructor xreg_to_reg xreg_to_reg)
(convert XReg Reg xreg_to_reg)

;; Convert a `XReg` to a `ValueRegs`.
(decl xreg_to_value_regs (XReg) ValueRegs)
(rule (xreg_to_value_regs x) (value_reg x))
(convert XReg ValueRegs xreg_to_reg)

;; Convert a `WritableXReg` to a `ValueRegs`.
(decl writable_xreg_to_value_regs (WritableXReg) ValueRegs)
(rule (writable_xreg_to_value_regs x) (value_reg x))
(convert WritableXReg ValueRegs writable_xreg_to_value_regs)

;; Allocates a new `WritableXReg`.
(decl temp_writable_xreg () WritableXReg)
(rule (temp_writable_xreg) (temp_writable_reg $I32))


;; Converters

(convert u8 i32 u8_as_i32)
(decl u8_as_i32 (u8) i32)
(extern constructor u8_as_i32 u8_as_i32)

;; ISA Extension helpers

(decl pure has_m () bool)
(extern constructor has_m has_m)

(decl pure has_v () bool)
(extern constructor has_v has_v)

(decl pure has_zfa () bool)
(extern constructor has_zfa has_zfa)

(decl pure has_zfh () bool)
(extern constructor has_zfh has_zfh)

(decl pure has_zbkb () bool)
(extern constructor has_zbkb has_zbkb)

(decl pure has_zba () bool)
(extern constructor has_zba has_zba)

(decl pure has_zbb () bool)
(extern constructor has_zbb has_zbb)

(decl pure has_zbc () bool)
(extern constructor has_zbc has_zbc)

(decl pure has_zbs () bool)
(extern constructor has_zbs has_zbs)

(decl pure has_zicond () bool)
(extern constructor has_zicond has_zicond)


;;;; Type Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Helper that matches any supported type. This extractor checks the ISA flags
;; to determine if the type is supported.
(decl ty_supported (Type) Type)
(extern extractor ty_supported ty_supported)


;;;; Instruction Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; RV32I Base Integer Instruction Set

;; Helper for emitting the `add` instruction.
;; rd ← rs1 + rs2
(decl rv_add (XReg XReg) XReg)
(rule (rv_add rs1 rs2)
  (alu_rrr (AluOPRRR.Add) rs1 rs2))

;; Helper for emitting the `addi` ("Add Immediate") instruction.
;; rd ← rs1 + sext(imm)
(decl rv_addi (XReg Imm12) XReg)
(rule (rv_addi rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Addi) rs1 imm))

;; Helper for emitting the `sub` instruction.
;; rd ← rs1 - rs2
(decl rv_sub (XReg XReg) XReg)
(rule (rv_sub rs1 rs2)
  (alu_rrr (AluOPRRR.Sub) rs1 rs2))

;; Helper for emitting the `neg` instruction.
;; This instruction is a mnemonic for `sub rd, zero, rs1`.
(decl rv_neg (XReg) XReg)
(rule (rv_neg rs1)
  (alu_rrr (AluOPRRR.Sub) (zero_reg) rs1))

;; Helper for emitting the `sll` ("Shift Left Logical") instruction.
;; rd ← rs1 << rs2
(decl rv_sll (XReg XReg) XReg)
(rule (rv_sll rs1 rs2)
  (alu_rrr (AluOPRRR.Sll) rs1 rs2))

;; Helper for emitting the `slli` ("Shift Left Logical Immediate") instruction.
;; rd ← rs1 << uext(imm)
(decl rv_slli (XReg Imm12) XReg)
(rule (rv_slli rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Slli) rs1 imm))

;; Helper for emitting the `srl` ("Shift Right Logical") instruction.
;; rd ← rs1 >> rs2
(decl rv_srl (XReg XReg) XReg)
(rule (rv_srl rs1 rs2)
  (alu_rrr (AluOPRRR.Srl) rs1 rs2))

;; Helper for emitting the `srli` ("Shift Right Logical Immediate") instruction.
;; rd ← rs1 >> uext(imm)
(decl rv_srli (XReg Imm12) XReg)
(rule (rv_srli rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Srli) rs1 imm))

;; Helper for emitting the `sra` ("Shift Right Arithmetic") instruction.
;; rd ← rs1 >> rs2
(decl rv_sra (XReg XReg) XReg)
(rule (rv_sra rs1 rs2)
  (alu_rrr (AluOPRRR.Sra) rs1 rs2))

;; Helper for emitting the `srai` ("Shift Right Arithmetic Immediate") instruction.
;; rd ← rs1 >> uext(imm)
(decl rv_srai (XReg Imm12) XReg)
(rule (rv_srai rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Srai) rs1 imm))

;; Helper for emitting the `or` instruction.
;; rd ← rs1 ∨ rs2
(decl rv_or (XReg XReg) XReg)
(rule (rv_or rs1 rs2)
  (alu_rrr (AluOPRRR.Or) rs1 rs2))

;; Helper for emitting the `ori` ("Or Immediate") instruction.
;; rd ← rs1 ∨ uext(imm)
(decl rv_ori (XReg Imm12) XReg)
(rule (rv_ori rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Ori) rs1 imm))

;; Helper for emitting the `xor` instruction.
;; rd ← rs1 ⊕ rs2
(decl rv_xor (XReg XReg) XReg)
(rule (rv_xor rs1 rs2)
  (alu_rrr (AluOPRRR.Xor) rs1 rs2))

;; Helper for emitting the `xori` ("Exclusive Or Immediate") instruction.
;; rd ← rs1 ⊕ uext(imm)
(decl rv_xori (XReg Imm12) XReg)
(rule (rv_xori rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Xori) rs1 imm))

;; Helper for emitting the `not` instruction.
;; This instruction is a mnemonic for `xori rd, rs1, -1`.
(decl rv_not (XReg) XReg)
(rule (rv_not rs1)
  (rv_xori rs1 (imm12_const -1)))

;; Helper for emitting the `and` instruction.
;; rd ← rs1 ∧ rs2
(decl rv_and (XReg XReg) XReg)
(rule (rv_and rs1 rs2)
  (alu_rrr (AluOPRRR.And) rs1 rs2))

;; Helper for emitting the `andi` ("And Immediate") instruction.
;; rd ← rs1 ∧ uext(imm)
(decl rv_andi (XReg Imm12) XReg)
(rule (rv_andi rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Andi) rs1 imm))

;; Helper for emitting the `slt` ("Set Less Than") instruction.
;; rd ← rs1 < rs2
(decl rv_slt (XReg XReg) XReg)
(rule (rv_slt rs1 rs2)
  (alu_rrr (AluOPRRR.Slt) rs1 rs2))

;; Helper for emitting the `sltu` ("Set Less Than Unsigned") instruction.
;; rd ← rs1 < rs2
(decl rv_sltu (XReg XReg) XReg)
(rule (rv_sltu rs1 rs2)
  (alu_rrr (AluOPRRR.SltU) rs1 rs2))

;; Helper for emitting the `snez` instruction.
;; This instruction is a mnemonic for `sltu rd, zero, rs`.
(decl rv_snez (XReg) XReg)
(rule (rv_snez rs1)
  (rv_sltu (zero_reg) rs1))

;; Helper for emitting the `slti` ("Set Less Than Immediate") instruction.
;; rd ← rs1 < imm
(decl rv_slti (XReg Imm12) XReg)
(rule (rv_slti rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Slti) rs1 imm))

;; Helper for emitting the `sltiu` ("Set Less Than Immediate Unsigned") instruction.
;; rd ← rs1 < imm
(decl rv_sltiu (XReg Imm12) XReg)
(rule (rv_sltiu rs1 imm)
  (alu_rr_imm12 (AluOPRRI.SltiU) rs1 imm))

;; Helper for emitting the `seqz` instruction.
;; This instruction is a mnemonic for `sltiu rd, rs, 1`.
(decl rv_seqz (XReg) XReg)
(rule (rv_seqz rs1)
  (rv_sltiu rs1 (imm12_const 1)))

;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrr (AluOPRRR Reg Reg) Reg)
(rule (alu_rrr op src1 src2)
      (let ((dst WritableXReg (temp_writable_xreg))
            (_ Unit (emit (MInst.AluRRR op dst src1 src2))))
        dst))

;; Helper for emitting `MInst.AluRRImm12` instructions.
(decl alu_rr_imm12 (AluOPRRI Reg Imm12) Reg)
(rule (alu_rr_imm12 op src imm)
      (let ((dst WritableXReg (temp_writable_xreg))
            (_ Unit (emit (MInst.AluRRImm12 op dst src imm))))
        dst))

; Helper for creating the zero register.
(decl zero_reg () XReg)
(extern constructor zero_reg zero_reg)
(extern extractor zero_reg is_zero_reg)

; Imm12 Rules

(decl pure imm12_zero () Imm12)
(rule (imm12_zero) (imm12_const 0))

(decl pure imm12_const (i32) Imm12)
(extern constructor imm12_const imm12_const)

(decl load_imm12 (i32) Reg)
(rule
  (load_imm12 x)
  (rv_addi (zero_reg) (imm12_const x)))




;; These types are for testing - i.e. check if we have an working ISLE file 

;; (type IntCC extern
;;     (enum
;;         Equal
;;         NotEqual
;;         SignedGreaterThan
;;         SignedGreaterThanOrEqual
;;         SignedLessThan
;;         SignedLessThanOrEqual
;;         UnsignedGreaterThan
;;         UnsignedGreaterThanOrEqual
;;         UnsignedLessThan
;;         UnsignedLessThanOrEqual
;;     )
;; )
;; 
;; (type TrapCode extern
;;     (enum
;;         BAD_CONVERSION_TO_INTEGER
;;         HEAP_OUT_OF_BOUNDS
;;         INTEGER_DIVISION_BY_ZERO
;;         INTEGER_OVERFLOW
;;         STACK_OVERFLOW
;;     )
;; )


;; (type WritableReg (primitive WritableReg))
;; (type Reg (primitive Reg))
;; (type MemFlags (primitive MemFlags))
;; (type MachLabel (primitive MachLabel))
;; (type UnwindInst (primitive UnwindInst))