;; Instruction formats.
(type MInst
  (enum
    ;; A no-op of zero size.
    (Nop0)
    (Nop4)

    ;; load immediate
    (Lui
      (rd WritableReg)
      (imm Imm20))

     (Auipc
      (rd WritableReg)
      (imm Imm20))
    
    ;; The LoadInlineConst operation represents the action of loading an immediate constant 
    ;; (a constant value) directly into a register. This operation is often used when you 
    ;; need to set a register to a specific constant value, such as zero, one, or any other 
    ;; immediate value, without needing to calculate it or load it from memory.
    (LoadInlineConst
      (rd WritableReg)
      (ty Type)
      (imm u32))
    
    (AluRRR
      (alu_op AluOPRRR)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg))

    ;; I-type Layout:
    ;; 0-------6-7-------11-12------14-15------19-20------------------31
    ;; | Opcode |   rd     |  width   |   rs1    |     Offset[11:0]    |

    ;; The I-type Instruction Format i.e. uses one source register, one immediate and a destination register.
    (AluRRImm12
      (alu_op AluOPRRI)
      (rd WritableReg)
      (rs Reg)
      (imm12 Imm12))

    ;; Uses the I-type Instruction Format. In non-immediate CSR instructions (CSRRW, CSRRS, CSRRC), rs1 is 
    ;; used to specify the register with the value to write.
    (CsrReg
      (op CsrRegOP)
      (rd WritableReg)
      (rs Reg)
      (csr CSR))

    ;; Uses the I-type Instruction Format. In immediate CSR instructions (CSRRWI, CSRRSI, CSRRCI), rs1 is 
    ;; replaced by a 5-bit immediate value.
    (CsrImm
      (op CsrImmOP)
      (rd WritableReg)
      (imm UImm5)
      (csr CSR))

    ;; Loads use the I-type Instruction Format.
    ;; Each load instruction in RV32I takes two operands
    ;; - A destination register (e.g., rd), where the data will be loaded.
    ;; - A base register (e.g., rs1) and an immediate offset, which together specify the memory address 
    ;; to load from.
    (Load
      (rd WritableReg)
      (op LoadOP)
      (flags MemFlags)
      (from AMode))
    
    ;; Pesudo load instructions

    ;; This operation loads the address of an external symbol (e.g., a function or global variable) 
    ;; into a register. In RISC-V, external symbols are often handled using relocation tables and 
    ;; require instructions like LUI to load the upper 20 bits of the address and ADDI to load the 
    ;; lower 12 bits.
    (LoadExtName
      (rd WritableReg)
      (name BoxExternalName)
      (offset i32))

    ;; This operation loads the address of a TLS (Thread-Local Storage) symbol into a register.
    ;; In RISC-V, accessing TLS typically involves a mechanism using the TLS base register 
    ;; (which stores the base address of the TLS area). The RISC-V instructions can then use 
    ;; PC-relative addressing or specialized instructions to load TLS data.
    (ElfTlsGetAddr
      (rd WritableReg)
      (name BoxExternalName))

    ;; This operation loads an address (a memory address or pointer) into a register.
    ;; RISC-V handles address calculation through instructions like add for register-based 
    ;; addressing or addi for immediate-based addressing.
    (LoadAddr
      (rd WritableReg)
      (mem AMode))
    
    ;; Uses the S-type Instruction Format.
    ;; Each store instruction in RV32I takes two operands:
    ;; - A source register (e.g., rs2), which holds the data to be stored.
    ;; - A base register (e.g., rs1) and an immediate offset, which together specify the memory address where 
    ;; the data will be stored.
    (Store
      (to AMode)
      (op StoreOP)
      (flags MemFlags)
      (src Reg))
    
    ;; A pseudo-instruction that captures register arguments in vregs.
    (Args
      (args VecArgPair))

    ;; A pseudo-instruction that moves vregs to return registers.
    (Rets
      (rets VecRetPair))

    (Ret)

    ;; A pseudo-instruction representing a register extension operation, typically used to modify the bit-width 
    ;; of data in a register (e.g., from 8-bit to 16-bit or 32-bit) by either sign-extending or zero-extending it.
    (Extend
      (rd WritableReg)
      (rn Reg)
      (signed bool)
      (from_bits u8)
      (to_bits u8))

    (Call (info BoxCallInfo))

    ;; A machine indirect-call instruction.
    (CallInd (info BoxCallIndInfo))

    ;; A direct return-call macro instruction.
    (ReturnCall (info BoxReturnCallInfo))

    ;; An indirect return-call macro instruction.
    (ReturnCallInd (info BoxReturnCallIndInfo))

    ;; Emits a trap with the given trap code if the comparison succeeds
    (TrapIf
      (rs1 Reg)
      (rs2 Reg)
      (cc IntCC)
      (trap_code TrapCode))
    
    ;; A pseudo-instruction for a conditional branch
    (CondBr
      (taken CondBrTarget)
      (not_taken CondBrTarget)
      (kind IntegerCompare))

    (Jal
      (label MachLabel))
    
    ;; A pseudo-instruction representing a `mov` instruction. These are encoded as OrR's (AluRRR form) but we
    ;; keep them separate at the `Inst` level for better pretty-printing and faster `is_move()` logic.
    (Mov
      (rd WritableReg)
      (rm Reg)
      (ty Type))
    

    (Fence
      (pred FenceReq)
      (succ FenceReq))

    (EBreak)

    ;; Conditional select i.e. select x if condition is true or y if condition is false. 
    (Select
      (dst WritableValueRegs)
      (condition IntegerCompare)
      (x ValueRegs)
      (y ValueRegs))

    ;; A pseudo-instruction. This operation represents a branch table or jump table operation, where a 
    ;; program can select one of several potential branch targets based on the value of an index 
    ;; register. This is useful for implementing switch-case logic or other scenarios where a single
    ;; control flow decision may have multiple possible outcomes.
    (BrTable
      (index Reg)
      (tmp1 WritableReg)
      (tmp2 WritableReg)
      (targets VecMachLabel))

    ;; An instruction guaranteed to always be undefined and to trigger an illegal instruction at
    ;; runtime.
    (Udf
      (trap_code TrapCode))
    
    ;; A jump and link register operation
    (Jalr
      ;;Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd=x0.
      (rd WritableReg)
      (base Reg)
      (offset Imm12))

    ;; An unwind pseudo-instruction.
    (Unwind
      (inst UnwindInst))

    ;; A dummy pseudo-instruction, useful to keep a value alive.
    (DummyUse
      (reg Reg))
    

    (RawData (data VecU8))

    ;; A pseudo-instruction to count the number of 1s in a register 
    ;; i.e., "population count" or "Hamming weight" without the hardware popcnt instruction.
    (Popcnt
      (sum WritableReg)
      (step WritableReg)
      (tmp WritableReg)
      (rs Reg)
      (ty Type))

    ;; A pseudo-instruction to count the number of leading or trailing zeros in `rs`
    (Cltz
      ;; leading or trailing.
      (leading bool)
      (sum WritableReg)
      (step WritableReg)
      (tmp WritableReg)
      (rs Reg)
      (ty Type))
    
    ;; A pseudo-instruction for a bit-reversal operation on an 8-bit value. 
    (Brev8
      (rs Reg)
      (ty Type)
      (step WritableReg)
      (tmp WritableReg)
      (tmp2 WritableReg)
      (rd WritableReg))

    ;; A pseudo-instruction for stack probing. 
    ;;
    ;; Allocating a large stack frame all at once can cause
    ;; issues, especially if it crosses over memory guard pages, which can
    ;; result in a segmentation fault or stack overflow.
    ;;
    ;; StackProbeLoop gradually allocates memory in smaller, safe increments
    ;; to ensure that each memory page is accessed in sequence. This way,
    ;; it prevents sudden large allocations from causing faults.
    ;;
    ;; Parameters:
    ;; - `guard_size` (u32): The size of each incremental allocation, typically
    ;;    matching the system's page size (e.g., 4KB).
    ;; - `probe_count` (u32): The total number of incremental steps needed to
    ;;    complete the allocation.
    ;; - `tmp` (WritableReg): A temporary register used for calculations in the loop.
    ;;
    ;; Example:
    ;; If you need 16KB of stack space and the `guard_size` is 4KB, StackProbeLoop
    ;; will allocate 4KB at a time, making four sequential increments.
    (StackProbeLoop
      (guard_size u32)
      (probe_count u32)
      (tmp WritableReg))
))

;; RV32I base set R-type
(type AluOPRRR (enum
  (Add)
  (Sub)
  (Sll)
  (Slt)
  (SltU)
  (Xor)
  (Srl)
  (Sra)
  (Or)
  (And)
))

;; RV32I base set I-type
(type AluOPRRI (enum
  (Addi)
  (Slti)
  (SltiU)
  (Xori)
  (Ori)
  (Andi)
  (Slli)
  (Srli)
  (Srai)
))

(type CsrRegOP (enum
  ;; Atomic Read/Write CSR
  (CsrRW)
  ;; Atomic Read and Set Bits in CSR
  (CsrRS)
  ;; Atomic Read and Clear Bits in CSR
  (CsrRC)
))

;; Enum of the known CSR registers
(type CSR (enum
  ;; Floating-Point Dynamic Rounding Mode
  (Frm)
))

(type CsrImmOP (enum
  ;; Atomic Read/Write CSR (Immediate Source)
  (CsrRWI)
  ;; Atomic Read and Set Bits in CSR (Immediate Source)
  (CsrRSI)
  ;; Atomic Read and Clear Bits in CSR (Immediate Source)
  (CsrRCI)
))

(type LoadOP (enum
  (Lb)
  (Lh)
  (Lw)
  (Lbu)
  (Lhu)
))

(type StoreOP (enum
  (Sb)
  (Sh)
  (Sw)
))


(type Imm20 (primitive Imm20))
(type Imm12 (primitive Imm12))
(type Imm5 (primitive Imm5))
(type UImm5 (primitive UImm5))
(type AMode (primitive AMode))
(type IntegerCompare (primitive IntegerCompare))
(type BoxCallInfo (primitive BoxCallInfo))
(type BoxCallIndInfo (primitive BoxCallIndInfo))
(type BoxReturnCallInfo (primitive BoxReturnCallInfo))
(type BoxReturnCallIndInfo (primitive BoxReturnCallIndInfo))
(type FenceReq (primitive u8))
(type CondBrTarget (primitive CondBrTarget))
(type VecU8 (primitive VecU8))
(type VecMachLabel extern (enum))

;;;; Newtypes for Different Register Classes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(type XReg (primitive XReg))
(type WritableXReg (primitive WritableXReg))
(type VReg (primitive VReg))
(type WritableVReg (primitive WritableVReg))

;; Construct a new `XReg` from a `Reg`.
;;
;; Asserts that the register has a Integer RegClass.
(decl xreg_new (Reg) XReg)
(extern constructor xreg_new xreg_new)
(convert Reg XReg xreg_new)

;; Construct a new `WritableXReg` from a `WritableReg`.
;;
;; Asserts that the register has a Integer RegClass.
(decl writable_xreg_new (WritableReg) WritableXReg)
(extern constructor writable_xreg_new writable_xreg_new)
(convert WritableReg WritableXReg writable_xreg_new)

;; Put a value into a XReg.
;;
;; Asserts that the value goes into a XReg.
(decl put_in_xreg (Value) XReg)
(rule (put_in_xreg val) (xreg_new (put_in_reg val)))
(convert Value XReg put_in_xreg)

;; Convert an `InstOutput` out of a single XReg register.
(decl output_xreg (XReg) InstOutput)
(rule (output_xreg x) (output_reg x))
(convert XReg InstOutput output_xreg)

;; Convert a `WritableXReg` to an `XReg`.
(decl pure writable_xreg_to_xreg (WritableXReg) XReg)
(extern constructor writable_xreg_to_xreg writable_xreg_to_xreg)
(convert WritableXReg XReg writable_xreg_to_xreg)

;; Convert a `WritableXReg` to an `WritableReg`.
(decl pure writable_xreg_to_writable_reg (WritableXReg) WritableReg)
(extern constructor writable_xreg_to_writable_reg writable_xreg_to_writable_reg)
(convert WritableXReg WritableReg writable_xreg_to_writable_reg)

;; Convert a `WritableXReg` to an `Reg`.
(decl pure writable_xreg_to_reg (WritableXReg) Reg)
(rule (writable_xreg_to_reg x) (writable_xreg_to_writable_reg x))
(convert WritableXReg Reg writable_xreg_to_reg)

;; Convert an `XReg` to a `Reg`.
(decl pure xreg_to_reg (XReg) Reg)
(extern constructor xreg_to_reg xreg_to_reg)
(convert XReg Reg xreg_to_reg)

;; Convert a `XReg` to a `ValueRegs`.
(decl xreg_to_value_regs (XReg) ValueRegs)
(rule (xreg_to_value_regs x) (value_reg x))
(convert XReg ValueRegs xreg_to_reg)

;; Convert a `WritableXReg` to a `ValueRegs`.
(decl writable_xreg_to_value_regs (WritableXReg) ValueRegs)
(rule (writable_xreg_to_value_regs x) (value_reg x))
(convert WritableXReg ValueRegs writable_xreg_to_value_regs)

;; Allocates a new `WritableXReg`.
(decl temp_writable_xreg () WritableXReg)
(rule (temp_writable_xreg) (temp_writable_reg $I32))


;; Converters

(convert u8 i32 u8_as_i32)
(decl u8_as_i32 (u8) i32)
(extern constructor u8_as_i32 u8_as_i32)

;; ISA Extension helpers

(decl pure has_m () bool)
(extern constructor has_m has_m)

(decl pure has_v () bool)
(extern constructor has_v has_v)

(decl pure has_zfa () bool)
(extern constructor has_zfa has_zfa)

(decl pure has_zfh () bool)
(extern constructor has_zfh has_zfh)

(decl pure has_zbkb () bool)
(extern constructor has_zbkb has_zbkb)

(decl pure has_zba () bool)
(extern constructor has_zba has_zba)

(decl pure has_zbb () bool)
(extern constructor has_zbb has_zbb)

(decl pure has_zbc () bool)
(extern constructor has_zbc has_zbc)

(decl pure has_zbs () bool)
(extern constructor has_zbs has_zbs)

(decl pure has_zicond () bool)
(extern constructor has_zicond has_zicond)


;;;; Type Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Helper that matches any supported type. This extractor checks the ISA flags
;; to determine if the type is supported.
(decl ty_supported (Type) Type)
(extern extractor ty_supported ty_supported)


;;;; Instruction Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; RV32I Base Integer Instruction Set

;; Helper for emitting the `add` instruction.
;; rd ← rs1 + rs2
(decl rv_add (XReg XReg) XReg)
(rule (rv_add rs1 rs2)
  (alu_rrr (AluOPRRR.Add) rs1 rs2))

;; Helper for emitting the `addi` ("Add Immediate") instruction.
;; rd ← rs1 + sext(imm)
(decl rv_addi (XReg Imm12) XReg)
(rule (rv_addi rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Addi) rs1 imm))

;; Helper for emitting the `sub` instruction.
;; rd ← rs1 - rs2
(decl rv_sub (XReg XReg) XReg)
(rule (rv_sub rs1 rs2)
  (alu_rrr (AluOPRRR.Sub) rs1 rs2))

;; Helper for emitting the `neg` instruction.
;; This instruction is a mnemonic for `sub rd, zero, rs1`.
(decl rv_neg (XReg) XReg)
(rule (rv_neg rs1)
  (alu_rrr (AluOPRRR.Sub) (zero_reg) rs1))

;; Helper for emitting the `sll` ("Shift Left Logical") instruction.
;; rd ← rs1 << rs2
(decl rv_sll (XReg XReg) XReg)
(rule (rv_sll rs1 rs2)
  (alu_rrr (AluOPRRR.Sll) rs1 rs2))

;; Helper for emitting the `slli` ("Shift Left Logical Immediate") instruction.
;; rd ← rs1 << uext(imm)
(decl rv_slli (XReg Imm12) XReg)
(rule (rv_slli rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Slli) rs1 imm))

;; Helper for emitting the `srl` ("Shift Right Logical") instruction.
;; rd ← rs1 >> rs2
(decl rv_srl (XReg XReg) XReg)
(rule (rv_srl rs1 rs2)
  (alu_rrr (AluOPRRR.Srl) rs1 rs2))

;; Helper for emitting the `srli` ("Shift Right Logical Immediate") instruction.
;; rd ← rs1 >> uext(imm)
(decl rv_srli (XReg Imm12) XReg)
(rule (rv_srli rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Srli) rs1 imm))

;; Helper for emitting the `sra` ("Shift Right Arithmetic") instruction.
;; rd ← rs1 >> rs2
(decl rv_sra (XReg XReg) XReg)
(rule (rv_sra rs1 rs2)
  (alu_rrr (AluOPRRR.Sra) rs1 rs2))

;; Helper for emitting the `srai` ("Shift Right Arithmetic Immediate") instruction.
;; rd ← rs1 >> uext(imm)
(decl rv_srai (XReg Imm12) XReg)
(rule (rv_srai rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Srai) rs1 imm))

;; Helper for emitting the `or` instruction.
;; rd ← rs1 ∨ rs2
(decl rv_or (XReg XReg) XReg)
(rule (rv_or rs1 rs2)
  (alu_rrr (AluOPRRR.Or) rs1 rs2))

;; Helper for emitting the `ori` ("Or Immediate") instruction.
;; rd ← rs1 ∨ uext(imm)
(decl rv_ori (XReg Imm12) XReg)
(rule (rv_ori rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Ori) rs1 imm))

;; Helper for emitting the `xor` instruction.
;; rd ← rs1 ⊕ rs2
(decl rv_xor (XReg XReg) XReg)
(rule (rv_xor rs1 rs2)
  (alu_rrr (AluOPRRR.Xor) rs1 rs2))

;; Helper for emitting the `xori` ("Exclusive Or Immediate") instruction.
;; rd ← rs1 ⊕ uext(imm)
(decl rv_xori (XReg Imm12) XReg)
(rule (rv_xori rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Xori) rs1 imm))

;; Helper for emitting the `not` instruction.
;; This instruction is a mnemonic for `xori rd, rs1, -1`.
(decl rv_not (XReg) XReg)
(rule (rv_not rs1)
  (rv_xori rs1 (imm12_const -1)))

;; Helper for emitting the `and` instruction.
;; rd ← rs1 ∧ rs2
(decl rv_and (XReg XReg) XReg)
(rule (rv_and rs1 rs2)
  (alu_rrr (AluOPRRR.And) rs1 rs2))

;; Helper for emitting the `andi` ("And Immediate") instruction.
;; rd ← rs1 ∧ uext(imm)
(decl rv_andi (XReg Imm12) XReg)
(rule (rv_andi rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Andi) rs1 imm))

;; Helper for emitting the `slt` ("Set Less Than") instruction.
;; rd ← rs1 < rs2
(decl rv_slt (XReg XReg) XReg)
(rule (rv_slt rs1 rs2)
  (alu_rrr (AluOPRRR.Slt) rs1 rs2))

;; Helper for emitting the `sltu` ("Set Less Than Unsigned") instruction.
;; rd ← rs1 < rs2
(decl rv_sltu (XReg XReg) XReg)
(rule (rv_sltu rs1 rs2)
  (alu_rrr (AluOPRRR.SltU) rs1 rs2))

;; Helper for emitting the `snez` instruction.
;; This instruction is a mnemonic for `sltu rd, zero, rs`.
(decl rv_snez (XReg) XReg)
(rule (rv_snez rs1)
  (rv_sltu (zero_reg) rs1))

;; Helper for emitting the `slti` ("Set Less Than Immediate") instruction.
;; rd ← rs1 < imm
(decl rv_slti (XReg Imm12) XReg)
(rule (rv_slti rs1 imm)
  (alu_rr_imm12 (AluOPRRI.Slti) rs1 imm))

;; Helper for emitting the `sltiu` ("Set Less Than Immediate Unsigned") instruction.
;; rd ← rs1 < imm
(decl rv_sltiu (XReg Imm12) XReg)
(rule (rv_sltiu rs1 imm)
  (alu_rr_imm12 (AluOPRRI.SltiU) rs1 imm))

;; Helper for emitting the `seqz` instruction.
;; This instruction is a mnemonic for `sltiu rd, rs, 1`.
(decl rv_seqz (XReg) XReg)
(rule (rv_seqz rs1)
  (rv_sltiu rs1 (imm12_const 1)))

;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrr (AluOPRRR Reg Reg) Reg)
(rule (alu_rrr op src1 src2)
      (let ((dst WritableXReg (temp_writable_xreg))
            (_ Unit (emit (MInst.AluRRR op dst src1 src2))))
        dst))

;; Helper for emitting `MInst.AluRRImm12` instructions.
(decl alu_rr_imm12 (AluOPRRI Reg Imm12) Reg)
(rule (alu_rr_imm12 op src imm)
      (let ((dst WritableXReg (temp_writable_xreg))
            (_ Unit (emit (MInst.AluRRImm12 op dst src imm))))
        dst))

; Imm12 Rules

(decl pure imm12_zero () Imm12)
(rule (imm12_zero) (imm12_const 0))

(decl pure imm12_const (i32) Imm12)
(extern constructor imm12_const imm12_const)

(decl load_imm12 (i32) Reg)
(rule
  (load_imm12 x)
  (rv_addi (zero_reg) (imm12_const x)))


;;;; Helpers for Emitting Calls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(decl gen_call (SigRef ExternalName RelocDistance ValueSlice) InstOutput)
(extern constructor gen_call gen_call)

(decl gen_call_indirect (SigRef Value ValueSlice) InstOutput)
(extern constructor gen_call_indirect gen_call_indirect)

(decl label_to_br_target (MachLabel) CondBrTarget)
(extern constructor label_to_br_target label_to_br_target)
(convert MachLabel CondBrTarget label_to_br_target)

;; Helpers

;; Load return address
(decl load_ra () Reg)
(extern constructor load_ra load_ra)

;; Perform an `AND` opertaion between an immediate and a u32.
(decl imm12_and (Imm12 u32) Imm12)
(extern constructor imm12_and imm12_and)

;; Helper for generating a i32 from a pair of Imm20 and Imm12 constants
(decl i32_generate_imm (Imm20 Imm12) i32)
(extern extractor i32_generate_imm i32_generate_imm)

;; Helper for generating a i32 from a shift of a Imm20 constant with LUI
(decl i32_shift_for_lui (u32 Imm12) i32)
(extern extractor i32_shift_for_lui i32_shift_for_lui)

;; Helper for generating a i32 from a shift of a Imm20 constant
(decl i32_shift (i32 Imm12) i32)
(extern extractor i32_shift i32_shift)


;; Imm12 Extractors

(decl imm12_from_u32 (Imm12) u32)
(extern extractor imm12_from_u32 imm12_from_u32)

(decl imm12_from_i32 (Imm12) i32)
(extern extractor imm12_from_i32 imm12_from_i32)

(decl pure partial u32_to_imm12 (u32) Imm12)
(rule (u32_to_imm12 (imm12_from_u32 n)) n)

(decl pure imm12_is_zero () Imm12)
(extern extractor imm12_is_zero imm12_is_zero)

;; Helper to go directly from a `Value`, when it's an `iconst`, to an `Imm12`.
(decl imm12_from_value (Imm12) Value)
(extractor (imm12_from_value n) (i32_from_iconst (imm12_from_i32 n)))


;; Imm20

;; Extractor that matches if a Imm20 is zero
(decl pure imm20_is_zero () Imm20)
(extern extractor imm20_is_zero imm20_is_zero)

(decl imm20_from_u32 (Imm20) u32)
(extern extractor imm20_from_u32 imm20_from_u32)

(decl imm20_from_i32 (Imm20) i32)
(extern extractor imm20_from_i32 imm20_from_i32)


;; Imm5 Extractors

(decl imm5_from_u32 (Imm5) u32)
(extern extractor imm5_from_u32 imm5_from_u32)

(decl imm5_from_i32 (Imm5) i32)
(extern extractor imm5_from_i32 imm5_from_i32)

;; Construct a Imm5 from an i8
(decl pure partial i8_to_imm5 (i8) Imm5)
(extern constructor i8_to_imm5 i8_to_imm5)

;; Helper to go directly from a `Value` to an `Imm5`.
(decl imm5_from_value (Imm5) Value)
(extractor (imm5_from_value n) (i32_from_iconst (imm5_from_i32 n)))


;; UImm5 Helpers

;; Extract a `UImm5` from an `u8`.
(decl pure partial uimm5_from_u8 (UImm5) u8)
(extern extractor uimm5_from_u8 uimm5_from_u8)

;; Extract a `UImm5` from an `u32`.
(decl pure partial uimm5_from_u32 (UImm5) u32)
(extern extractor uimm5_from_u32 uimm5_from_u32)

;; Convert a `u32` into an `UImm5`
(decl pure partial u32_to_uimm5 (u32) UImm5)
(rule (u32_to_uimm5 (uimm5_from_u32 n)) n)

(decl uimm5_bitcast_to_imm5 (UImm5) Imm5)
(extern constructor uimm5_bitcast_to_imm5 uimm5_bitcast_to_imm5)


;; Helpers for immediate loads

(decl imm_from_bits (u32) Imm12)
(extern constructor imm_from_bits imm_from_bits)

(decl imm_from_neg_bits (i32) Imm12)
(extern constructor imm_from_neg_bits imm_from_neg_bits)

(decl imm12_const_add (i32 i32) Imm12)
(extern constructor imm12_const_add imm12_const_add)

;; Performs a fallible add of the `Imm12` value and the 32-bit value provided.
(decl pure partial imm12_add (Imm12 i32) Imm12)
(extern constructor imm12_add imm12_add)


;; AMode Helpers

;; Generates a AMode that points to a register plus an offset.
(decl gen_reg_offset_amode (Reg i32) AMode)
(extern constructor gen_reg_offset_amode gen_reg_offset_amode)

;; Generates a AMode that an offset from the stack pointer.
(decl gen_sp_offset_amode (i32) AMode)
(extern constructor gen_sp_offset_amode gen_sp_offset_amode)

;; Generates a AMode that an offset from the frame pointer.
(decl gen_fp_offset_amode (i32) AMode)
(extern constructor gen_fp_offset_amode gen_fp_offset_amode)

;; Generates an AMode that points to a stack slot + offset.
(decl gen_stack_slot_amode (StackSlot i32) AMode)
(extern constructor gen_stack_slot_amode gen_stack_slot_amode)

;; Generates a AMode that points to a constant in the constant pool.
(decl gen_const_amode (VCodeConstant) AMode)
(extern constructor gen_const_amode gen_const_amode)

;; Helpers for sinkable loads ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; RISC-V doesen't really have sinkable loads. But the regular load instructions
;; sign / zero extend their results to 64 bits. So we can pretend they are
;; an extend instruction with a sinkable load. This allows us to have better
;; lowerings on these cases.

;; Extract a sinkable instruction from a value operand.
(decl sinkable_inst (Inst) Value)
(extern extractor sinkable_inst sinkable_inst)


;; Load and Store Ops

(decl load_op (Type) LoadOP)
(extern constructor load_op load_op)

(decl store_op (Type) StoreOP)
(extern constructor store_op store_op)

;;;; load extern name
(decl load_ext_name (ExternalName i32) Reg)
(extern constructor load_ext_name load_ext_name)

;; Stack Operations

(decl gen_stack_addr (StackSlot Offset32) Reg)
(extern constructor gen_stack_addr gen_stack_addr)

;; Branch Ops

(decl lower_br_table (Reg MachLabelSlice) Unit)
(extern constructor lower_br_table lower_br_table)

;;;; Helpers for physical registers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(decl fp_reg () PReg)
(extern constructor fp_reg fp_reg)

(decl sp_reg () PReg)
(extern constructor sp_reg sp_reg)

;; Extractor that matches all registers, except the zero register
(decl non_zero_reg () XReg)
(extern extractor non_zero_reg is_non_zero_reg)

;; Helper for creating the zero register.
(decl zero_reg () XReg)
(extern constructor zero_reg zero_reg)
(extern extractor zero_reg is_zero_reg)

(decl writable_zero_reg () WritableReg)
(extern constructor writable_zero_reg writable_zero_reg)


;; IntegerCompare

;; Construct an IntegerCompare value.
(decl int_compare (IntCC XReg XReg) IntegerCompare)
(extern constructor int_compare int_compare)

;; Extract the components of an `IntegerCompare`
(decl int_compare_decompose (IntCC XReg XReg) IntegerCompare)
(extern extractor infallible int_compare_decompose int_compare_decompose)


;; Defintions used in lowering rules

;; Declare a function to load immediates and attach immediate loading rules
(decl imm (Type u32) Reg)

;; Try to match just an imm12
(rule 4 (imm (ty_int ty) c)
  (if-let (i32_generate_imm (imm20_is_zero) imm12) (i32_sextend_u32 ty c))
  (rv_addi (zero_reg) imm12))

;; We can also try to load using a single LUI.
;; LUI takes a 20 bit immediate, places it on bits 13 to 32 of the register.
;; In RV32 this value is then sign extended to 64bits.
(rule 3 (imm (ty_int ty) c)
  (if-let (i32_generate_imm imm20 (imm12_is_zero)) (i32_sextend_u32 ty c))
  (rv_lui imm20))

;; We can combo addi + lui to represent all 32-bit immediates
;; And some 64-bit immediates as well.
(rule 2 (imm (ty_int ty) c)
  (if-let (i32_generate_imm imm20 imm12) (i32_sextend_u32 ty c))
  (rv_addi (rv_lui imm20) imm12))

;; If the non-zero bits of the immediate fit in 20 bits, we can use LUI + shift
(rule 1 (imm (ty_int ty) c)
  (if-let (i32_shift_for_lui (imm20_from_u32 base) shift) (i32_sextend_u32 ty c))
  (rv_slli (rv_lui base) shift))

;; Combine one of the above rules with a shift-left if possible, This chops off
;; all trailing zeros from the input constant and then attempts if the resulting
;; constant can itself use one of the above rules via the `i32_generate_imm`
;; matcher. This will then recurse on the above rules to materialize a smaller
;; constant which is then shifted left to create the desired constant.
(rule 0 (imm (ty_int ty) c)
  (if-let (i32_shift c_shifted shift) (i32_sextend_u32 ty c))  ;; constant to make
  (if-let (i32_generate_imm _ _) c_shifted)                    ;; can the smaller constant be made?
  (rv_slli (imm ty (i32_as_u32 c_shifted)) shift))

;; Otherwise we fall back to loading the immediate from the constant pool.
(rule -1 (imm (ty_int ty) c)
  (gen_load
    (gen_const_amode (emit_u32_le_const c))
    (LoadOP.Lw)
    (mem_flags_trusted)))


;; Helper Constructors

;; Helper constructor to build a load instruction.
(decl gen_load (AMode LoadOP MemFlags) Reg)
(rule (gen_load amode op flags)
  (let ((dst WritableReg (temp_writable_reg (load_op_reg_type op)))
      (_ Unit (emit (MInst.Load dst op flags amode))))
    dst))

;; Returns a canonical type for a LoadOP. We only return I32.
(decl load_op_reg_type (LoadOP) Type)
(rule 0 (load_op_reg_type _) $I32)

;; Helper for emitting the `Lui` instruction.
;; TODO: This should be something like `emit_u_type`. And should share the
;; `MInst` with `auipc` since these instructions share the U-Type format.
(decl rv_lui (Imm20) XReg)
(rule (rv_lui imm)
      (let ((dst WritableXReg (temp_writable_xreg))
            (_ Unit (emit (MInst.Lui dst imm))))
        dst))

(decl select_addi (Type) AluOPRRI)
(rule (select_addi (fits_in_32 ty)) (AluOPRRI.Addi))

(decl partial lower_branch (Inst MachLabelSlice) Unit)
(rule (lower_branch (jump _) (single_target label))
      (emit_side_effect (rv_j label)))

(rule (lower_branch (brif v _ _) (two_targets then else))
  (emit_side_effect (cond_br (is_nonzero_cmp v) then else)))

(rule (lower_branch (br_table index _) targets)
  (lower_br_table index targets))

;; Helper for emitting the `j` mnemonic, an unconditional jump to label.
(decl rv_j (MachLabel) SideEffectNoResult)
(rule (rv_j label)
  (SideEffectNoResult.Inst (MInst.Jal label)))

;; Consume a CmpResult, producing a branch on its result.
(decl cond_br (IntegerCompare CondBrTarget CondBrTarget) SideEffectNoResult)
(rule (cond_br cmp then else)
      (SideEffectNoResult.Inst
        (MInst.CondBr then else cmp)))



(decl cmp_nez (XReg) IntegerCompare)
(rule (cmp_nez r) (int_compare (IntCC.NotEqual) r (zero_reg)))


;; Helper to generate an `IntegerCompare` which represents the "truthy" value of
;; the input provided.
;;
;; This is used in `Select` and `brif` for example to generate conditional
;; branches. The returned comparison, when taken, represents that `Value` is
;; nonzero. When not taken the input `Value` is zero.
(decl is_nonzero_cmp (Value) IntegerCompare)

;; Base case - convert to a "truthy" value and compare it against zero.
;;
;; Note that non-64-bit types need to be extended since the upper bits from
;; Cranelift's point of view are undefined. Favor a zero extension for 8-bit
;; types because that's a single `andi` instruction, but favor sign-extension
;; for 16 and 32-bit types because many RISC-V which operate on the low 32-bits.
;; Additionally the base 64-bit ISA has a single instruction for sign-extending
;; from 32 to 64-bits which makes that a bit cheaper if used.
;; of registers sign-extend the results.
(rule 0 (is_nonzero_cmp val @ (value_type (fits_in_32 _)))
  (cmp_nez (sext val)))
(rule 1 (is_nonzero_cmp val @ (value_type $I8))
  (cmp_nez (zext val)))


;; Performs a signed extension of the given value
(decl sext (Value) XReg)

;; Same base case as `zext`, shift left-then-right.
(rule 0 (sext val @ (value_type (fits_in_32 ty)))
  (let ((shift Imm12 (imm_from_bits (u32_sub 32 (ty_bits ty)))))
    (rv_srai (rv_slli val shift) shift)))

;; Performs a zero extension of the given value
(decl zext (Value) XReg)

;; In the most generic case, we shift left and then shift right.
(rule 0 (zext val @ (value_type (fits_in_32 ty)))
  (let ((shift Imm12 (imm_from_bits (u32_sub 32 (ty_bits ty)))))
    (rv_srli (rv_slli val shift) shift)))

;; These types are for testing - i.e. check if we have an working ISLE file 

;; (type IntCC extern
;;     (enum
;;         Equal
;;         NotEqual
;;         SignedGreaterThan
;;         SignedGreaterThanOrEqual
;;         SignedLessThan
;;         SignedLessThanOrEqual
;;         UnsignedGreaterThan
;;         UnsignedGreaterThanOrEqual
;;         UnsignedLessThan
;;         UnsignedLessThanOrEqual
;;     )
;; )
;; 
;; (type TrapCode extern
;;     (enum
;;         BAD_CONVERSION_TO_INTEGER
;;         HEAP_OUT_OF_BOUNDS
;;         INTEGER_DIVISION_BY_ZERO
;;         INTEGER_OVERFLOW
;;         STACK_OVERFLOW
;;     )
;; )


;; (type WritableReg (primitive WritableReg))
;; (type Reg (primitive Reg))
;; (type MemFlags (primitive MemFlags))
;; (type MachLabel (primitive MachLabel))
;; (type UnwindInst (primitive UnwindInst))